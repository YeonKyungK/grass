---
description: '객체 초기화, 사용자 정의 획득자와 설정자, 나중 초기화, 지연 초기화, 싱글톤 생성하기, Nothing 클래스 이해하기'
---

# 3장 코틀린 객체 지향 프로그래밍

## const 와 val 차이 이해하기 

### const

* 컴파일 타임 상수에 const 사용
* 객체나 companion object 선언의 최상위 속성 또는 멤버여야 한다.
* 문자열 또는 기본 타입의 래퍼클래스\(Byte, Short, Int, Long, Float, Double, Char, Boolean\)
* 사용자 정의 획득자\(getter\) 를 가질 수 없다.
* 컴파일 시점에 사용할 수 있도록 main 함수를 포함한 모든 함수의 바깥쪽에 할당돼야 한다.

### val

* 한 번 할당되면 변경이 불가능 함 
* 자바에서는 final 키워드와 같은 목

```kotlin
class Task(val name: String, _priority: Int = DEFAULT_PRIORITY) {
    companion object {
        const val MIN_PRIORITY = 1
        const val MAX_PRIORITY = 5
        const val DEFAULT_PRIORITY = 3
    }
    
    var priority = validPriority(_priority)
        set(value) {
            field = validPriority(value)
        }
        
    private fun validPriority(p: Int) = 
        p.coerceIn(MIN_PRIORITY, MAX_PRIORITY)
}
```

> 코틀린에서 val 은 키워드지만 const 는 private, inline 등과 같은 변경자임에 유의하자 
>
> const 는 val 를 대체하는 것이 아니라 반드시 같이 쓰여야 한다.

## 사용자 정의 획득자와 설정자 생성하기

코틀린 클래스는 데이터와 보통 캡슐화로 알려진 해당 데이터를 조작하는 함수로 이뤄진다.  
특이하게도 모든 것이 기본적으로 public 이다.

정보와 연관된 데이터 구조의 세부 구현이 필요하다고 추정되며 이는 데이터 은닉 원칙을 침해하는 것 처럼 보인다. 

```kotlin
class task(val name: String) {
    var priority = 3
}
```

priority 를 선언할 때는 apply 블록을 사용해서 해당 값을 할당해야 된다.  
즉, 클래스를 인스턴스화할 때 priority 에 값을 할당할 수 없다.

```kotlin
var myTask = task().apply { priority = 4 }
```

이 방식으로 속성을 정의하면 장점은 쉽게 사용자 정의 획득자와 설정자를 추가할 수 있다는 점이다.

```kotlin
var <propertyName>[ :<PropertyType>] [= <property_initializer>]
    [<getter>]
    [<setter>]
```

속성 타입이 초기값 또는 획득자\(getter\) 의 리턴 타입에서 추론 가능하다면 속성 타입 또한 선택사항이다.  
초기화 블록, 획득자, 설정자도 선택사항이다.

{% hint style="warning" %}
생성자에서 선언한 속성에는 반드시 타입 정의가 있어야 된다.
{% endhint %}

```kotlin
val isLowPriorty
    get() = priority < 3 // 리턴 타입은 Boolean
```

```kotlin
var priority = 3
    set(value) {
        field = value.coerceIn(1..5) // 1과 5사이의 값이 되어야 한다. 
    }
```

일반적으로 속성에는 지원필드가 필요하지만 코틀린에서는 자동으로 지원필드\(backing field\)를 생성한다.   
오히려 get\(\) 에서 속성 타입을 가지고 올 수 있었다. 

field 식별자는 코틀린이 생성한 지원필드를 참조하는데 사용 된다. getter 나 setter 에서만 사용 가능하다.

## 데이터 클래스 정의하기

* equals
* hashCode
* toString
* copy
* component

함수를 제공하는 data class 

### copy 함수

```kotlin
@Test
fun `change price using copy()` {
    val p1 = Product("baseball", 10.0)
    val p2 = p1.copy(price = 12.0)
    assertAll(
        { assertEquals("baseball", p2.game) }, // true
        { assertThat(p2.price, `is`(closeTo(12.0, 0.01))) }, // true
        { assertFalse(p2.onSale) } // true
    )
}
```

copy 는 깊은 복사가 아니라 얕은 복사를 수행한다. 

### component 함수

```kotlin
@Test
fun `destructure using component functions`() {
    val p = Product("baseball", 10.0)
    
    val (name, price, sale) = p
    assertAll(
        { assertEquals(p.name, name) },
        { assertThat(p.price, `is`(closeTo(price, 0.01))) },
        { assertFalse(sale) }
    )
}
```

## 지원 속성 기법

클래스의 속성을 클라이언트에 노출하고 싶지만 **해당 속성을 초기화하거나 읽는 방법을 제어해야** 되는 기법

같은 타입의 속성을 하나 더 정의하고 사용자 정의 획득자와 설정자를 이용해 원하는 속성에 접근한다.

```kotlin
class Customer(val name: String) {
    
    val messages: List<String> by lazy { loadMessages() } // lazy 사용
    
    private fun loadMessages() : MutableList<String> = 
        mutableListOf(
            " ...",
            " ~~~",
        ).also { println("loaded messages") }
}
```

```kotlin
class Task(val name: String, _priority: Int = DEFAULT_PRIORITY) { 
//_priority 가 backing property 로 보면 
    companion object {
        const val MIN_PRIORITY = 1
        const val MAX_PRIORITY = 5
        const val DEFAULT_PRIORITY = 3
    }
    
    var priority = validPriority(_priority)
        set(value) {
            field = validPriority(value)
        }
        
    private fun validPriority(p: Int) = 
        p.coerceIn(MIN_PRIORITY, MAX_PRIORITY)
}
```

```kotlin
class Human {
    private val _age: Int = 20 // backing property
    val age: Int
        get() {
            return _age
        }

     val printAge = {
         println("Age is: $_age")
     }
}
// 출처 : https://proandroiddev.com/backing-properties-in-kotlin-cb78dfebfd90
```

