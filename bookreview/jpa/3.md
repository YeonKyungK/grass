# 3장 영속성 관리

이 장에서는 매핑한 엔티티를 엔티티 매니저를 통해 어떻게 사용하는지 알아보자 

개발자 입장에서 엔티티 매니저는 엔티티를 저장하는 가상의 데이터베이스로 생각하면 된다.

## 엔티티 매니저 팩토리와 엔티티 매니저 

{% hint style="info" %}
* 엔티티 매니저 팩토리를 만드는 비용은 상당히 크다.
* 따라서 한 개만 만들어서 애플리케이션 전체에서 공유하도록 설계 
* 반면에 공장에서 엔티티 매니저를 생성하는 비용은 거의 들지 않는다.
{% endhint %}

{% hint style="danger" %}
* 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전
* 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제 발생
{% endhint %}

## 영속성 컨텍스트란?

#### Persistence Context = 엔티티를 영구 저장하는 환경

* 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관,관리한다.
* 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다.

{% hint style="info" %}
여러 엔티티매니저가 같은 영속성 컨텍스트에 접근 가능 \(자세한 건 11장에서...\)
{% endhint %}

## 엔티티의 생명주기 

![](../../.gitbook/assets/entity_lifecycle.jpg)

#### 엔티티의 4가지 상태

1. 비영속\(new/transient\) : 영속성 컨텍스트와 전혀 관계가 없는 상태
2. 영속\(managed\) : 영속성 컨텍스트에 저장된 상태
3. 준영속\(detached\) : 영속성 컨텍스트에 저장되었다가 분리된 상태
4. 삭제\(removed\) : 삭제된 상태 

### 비영속 

* 엔티티 객체를 생성함
* 순수한 객체 상태이며 아직 저장하지 않았다
* 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다.

```java
// 객체만 생성한 상태
Member meber = new Member();
member.setId("member1");
member.setUsername("회원1");
```

### 영속

* 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장했다. 
* 영속성 컨텍스트가 관리하는 상태이므로 영속 상태

```java
// 객체를 저장한 상태
em.persist(member);
```

### 준영속

* 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리 하지 않으면 준영속
* 준영속 상태로 만들려면 `em.detach()` 를 호출
* 아니면 `em.close()` 를 호출해서 영속성 컨텍스트를 닫거나
* `em.clear()` 을 호출해서 영속성 컨텍스트를 초기화 시켜도 준영속이 된다. 

### 삭제

* 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제

```java
// 객체를 삭제한 상태
em.remove(member);
```

## 영속성 컨텍스트의 특징

### 영속성 컨텍스트와 식별자 값

* 영속성 컨텍스트는 엔티티를 식별자 값\(@Id 로 테이블의 기본 키와 매핑한 값\) 으로 구분
* **영속 상태는 식별자 값이 반드시 있어야 한다.** 

### **영속성 컨텍스트와 데이터베이스 저장**

* 영속성 컨텍스트에 엔티티를 저장하면 이 엔티티는 언제 데이터베이스에 저장될까?
* JPA 는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터 베이스에 반영 &gt;&gt; Flush\(플러시\) 라고 한다.

### 영속성 컨텍스트가 엔티티를 관리하면 나오는 장점

1. 1차 캐시
2. 동일성 보장
3. 트랜잭션을 지원하는 쓰기 지연
4. 변경 감지
5. 지연 로딩 

## 영속성 컨텍스트를 사용하는 이유

### 엔티티 조회

* 영속성 컨텍스트는 내부에 캐시를 가지고 있음 \( 1차 캐시 라고함 \)
* 영속성 컨텍스트 내부에 `Map` 이 하나 있는 데 키는 `@Id` 로 매핑한 식별자이고 값은 엔티티 인스턴스 

![&#xC544;&#xC9C1; &#xC5D4;&#xD2F0;&#xD2F0;&#xB294; &#xB370;&#xC774;&#xD130; &#xBCA0;&#xC774;&#xC2A4;&#xC5D0; &#xC800;&#xC7A5;&#xC548;&#xB428; ](../../.gitbook/assets/1-.png)

* 영속성 컨텍스트에 데이터를 저장하고 조회하는 모든 기준은 데이터베이스 기본 키 값이다.

#### 1차 캐시에서 조회

![](../../.gitbook/assets/1-%20%281%29.png)

```java
// 1차 캐시에서 조회 
Member findMember = em.find(Member.class, "member1");
```

#### 데이터베이스에서 조회

* em.find\(\) 를 호출했는데 만약 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성한다. 
* 그리고 1차 캐시에 저장한 뒤 영속 상태의 엔티티를 반환한다.

![em.find\(Member.class, &quot;member2&quot;\)](../../.gitbook/assets/.png%20%286%29.png)

* 이렇게 되면 member1, member2 가 1차 캐시에서 있어서 바로 불러올 수 있어서 성능상 이점이 있다!

### 영속 엔티티의 동일성 보장 

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b); // 동일성 비교
```

* `em.find(Member.class, "member1");` 을 반복해서 호출해도 영속성 컨텍스트는 1차 캐시에 있는 같은 엔티티 인스턴스를 반환한다. 
* 위 예제에서 당연히  a 와 b 는 같은 인스턴스다.
* **영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장**한다. 

### 엔티티 등록 

```java
EntityManager em = emf.createEntityManager();
EntityTransaction transaction = em.getTransaction();
// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야 한다
transaction.begin(); // [트랜잭션] 시작

em.persist(memberA);
em.persist(memberB); 
// 영속 상태이며, DB INSERT SQL을 보내지 않음

transaction.commit(); // [트랜잭션] 커밋
```

* 엔티티 매니저는 트랙잭션을 커밋하기 직전까지 내부 쿼리 저장소에 INSERT SQL 을 차곡차곡 모아둔다.
* 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는 데
* 이것을 트랜잭션을 지원하는 **쓰기 지연\(transactional write-behind\)** 라고 한다. 

![](../../.gitbook/assets/.png%20%285%29.png)

